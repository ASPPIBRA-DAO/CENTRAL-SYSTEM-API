üöÄ Iniciando mapeamento do Governance System Backend...
Data: Thu Feb  5 12:21:18 AM UTC 2026
------------------------------------------------

üìÇ 1. √ÅRVORE DE DIRET√ìRIOS:
.
./package.json
./ESTRUTURA_BACKEND_REPORT.txt
./scripts
./scripts/cloudflare-analytics.js
./scripts/fetch-ids.js
./scripts/build-seo.mjs
./scripts/audit-architecture-v4.js
./scripts/audit-project.js
./public
./public/img
./public/img/social-preview.png
./public/favicon.ico
./public/site.webmanifest
./public/js
./public/js/dashboard.js
./public/sitemap.xml
./public/icons
./public/icons/favicon-32x32.png
./public/icons/android-chrome-512x512.png
./public/icons/android-chrome-192x192.png
./public/icons/favicon-16x16.png
./public/icons/apple-touch-icon.png
./public/css
./public/css/style.css
./public/robots.txt
./debug_asppibra.sh
./test
./test/env.d.ts
./test/index.spec.ts
./test/tsconfig.json
./migrations
./migrations/0000_unique_red_hulk.sql
./migrations/0002_tearful_jack_murdock.sql
./migrations/0003_confused_typhoid_mary.sql
./migrations/meta
./migrations/meta/0003_snapshot.json
./migrations/meta/_journal.json
./migrations/meta/0001_snapshot.json
./migrations/meta/0002_snapshot.json
./migrations/meta/0000_snapshot.json
./migrations/0001_furry_sunspot.sql
./wrangler.jsonc
./pnpm-lock.yaml
./LICENSE
./drizzle.config.ts
./src
./src/routes
./src/routes/products
./src/routes/products/blog.ts
./src/routes/products/rwa
./src/routes/products/agro
./src/routes/products/posts
./src/routes/core
./src/routes/core/webhooks.ts
./src/routes/core/health.ts
./src/routes/core/auth
./src/routes/platform
./src/routes/platform/storage.ts
./src/routes/platform/payments.ts
./src/index.ts
./src/services
./src/services/market.ts
./src/services/auth.ts
./src/services/email.ts
./src/services/audit.ts
./src/utils
./src/utils/auth-guard.ts
./src/utils/response.ts
./src/middleware
./src/middleware/rate-limit.ts
./src/middleware/auth.ts
./src/views
./src/views/dashboard.ts
./src/validators
./src/validators/auth.ts
./src/types
./src/types/manifest.d.ts
./src/types/bindings.d.ts
./src/db
./src/db/index.ts
./src/db/schema.ts
./vitest.config.mts
./map_backend.sh
./README.md
./update_users_table.sql
./tsconfig.json
./worker-configuration.d.ts

------------------------------------------------

üóÑÔ∏è 2. SCHEMA DO BANCO DE DADOS (src/db/schema.ts):
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Database Schema (Drizzle ORM + SQLite D1)
 * Version: 1.2.0 - Real Identity & SocialFi Integration
 */
import { sqliteTable, text, integer, index, uniqueIndex } from "drizzle-orm/sqlite-core";
import { sql } from "drizzle-orm";

// === 1. TABELA DE USU√ÅRIOS (Sincronizado com AuthGuard do Frontend) ===
export const users = sqliteTable('users', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  
  // Identidade Web2
  firstName: text('first_name').notNull(),
  lastName: text('last_name').notNull(),
  email: text('email').notNull().unique(),
  password: text('password').notNull(), 

  // Status de Verifica√ß√£o
  emailVerified: integer('email_verified', { mode: 'boolean' }).default(false),
  avatarUrl: text('avatar_url'),

  // Seguran√ßa (Snake_case para o DB, CamelCase para o c√≥digo)
  mfaSecret: text('mfa_secret'), 
  mfaEnabled: integer('mfa_enabled', { mode: 'boolean' }).default(false),

  // Compliance & Governan√ßa
  kycStatus: text('kyc_status', { enum: ['none', 'pending', 'approved', 'rejected'] }).default('none'),
  role: text('role', { enum: ['citizen', 'partner', 'admin', 'system'] }).default('citizen'),

  // Timestamps em formato Unix (Melhor performance no D1)
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
}, (table) => ({
  emailIdx: index('idx_users_email').on(table.email),
  roleIdx: index('idx_users_role').on(table.role),
}));

// === 2. SEGURAN√áA: RECUPERA√á√ÉO DE SENHA ===
export const passwordResets = sqliteTable('password_resets', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  token: text('token').notNull().unique(), 
  expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
  used: integer('used', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
});

// === 3. CARTEIRAS (IDENTIDADE WEB3 / TOKENIZA√á√ÉO) ===
export const wallets = sqliteTable('wallets', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  address: text('address').notNull().unique(),
  chainId: integer('chain_id').notNull(),
  isPrimary: integer('is_primary', { mode: 'boolean' }).default(false),
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
});

// ======================================================================
// === 4. M√ìDULO SOCIALFI (POSTS & BLOG) ===
// ======================================================================

export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  authorId: integer('author_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  
  title: text('title').notNull(),
  slug: text('slug').notNull().unique(),
  description: text('description'), // Meta Description e Cards
  content: text('content').notNull(),
  coverUrl: text('cover_url'),
  
  category: text('category').default('Geral'),
  tags: text('tags', { mode: 'json' }).$type<string[]>(), // Tags din√¢micas em JSON
  
  // M√©tricas SocialFi
  totalViews: integer('total_views').default(0),
  totalShares: integer('total_shares').default(0),
  totalFavorites: integer('total_favorites').default(0),
  timeToRead: integer('time_to_read').default(5), // Minutos estimados

  // Controle de Destaque e Governan√ßa
  isFeatured: integer('is_featured', { mode: 'boolean' }).default(false),
  isTrending: integer('is_trending', { mode: 'boolean' }).default(false),

  // üü¢ AJUSTE: Renomeado para 'publish' para bater com o Front-end
  publish: integer('publish', { mode: 'boolean' }).default(true),
  
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
}, (table) => ({
  slugIdx: index('idx_posts_slug').on(table.slug),
  publishIdx: index('idx_posts_publish').on(table.publish),
  categoryIdx: index('idx_posts_category').on(table.category),
}));

// --- Coment√°rios ---
export const postComments = sqliteTable('post_comments', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  postId: integer('post_id')
    .notNull()
    .references(() => posts.id, { onDelete: 'cascade' }),
  userId: integer('user_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  
  content: text('content').notNull(),
  likes: integer('likes').default(0), 
  
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
});

// --- üü¢ NOVO: Favoritos (Social Proof & SocialFi) ---
// Essencial para o componente de AvatarGroup no Front-end
export const postFavorites = sqliteTable('post_favorites', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  postId: integer('post_id')
    .notNull()
    .references(() => posts.id, { onDelete: 'cascade' }),
  userId: integer('user_id')
    .notNull()
    .references(() => users.id, { onDelete: 'cascade' }),
  
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
}, (table) => ({
  uniqueFavoriteIdx: uniqueIndex('unique_post_user_favorite').on(table.postId, table.userId),
}));


// === 5. GEST√ÉO DE ATIVOS (RWA) & CONTRATOS ===
export const contracts = sqliteTable('contracts', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  userId: integer('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
  
  description: text('description').notNull(), 
  totalValue: integer('total_value').notNull(), // Valor em centavos
  totalInstallments: integer('total_installments'),
  
  status: text('status', { enum: ['active', 'completed', 'defaulted'] }).default('active'),
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
});

// ======================================================================
// === 6. LOGS DE AUDITORIA (TRANSPAR√äNCIA DAO) ===
// ======================================================================

export const auditLogs = sqliteTable('audit_logs', {
  id: integer('id').primaryKey({ autoIncrement: true }),
  actorId: integer('actor_id').references(() => users.id),
  
  action: text('action').notNull(), // Ex: 'BLOG_POST_CREATE', 'USER_LOGIN'
  status: text('status').default('success'), // 'success' | 'failure'
  ipAddress: text('ip_address'),
  
  // Metadados para auditoria forense (JSON com detalhes da mudan√ßa)
  metadata: text('metadata', { mode: 'json' }), 
  
  createdAt: integer('created_at', { mode: 'timestamp' }).default(sql`(strftime('%s', 'now'))`),
}, (table) => ({
  actionIdx: index('idx_audit_action').on(table.action),
  actorIdx: index('idx_audit_actor').on(table.actorId),
}));
------------------------------------------------

üåê 3. DEFINI√á√ÉO DE ROTAS (src/index.ts ou src/routes/):
/**
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 * Entry Point: Cloudflare Worker (Hono Framework)
 */

import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { Bindings } from './types/bindings';
import { createDb, Database } from './db';
import { error } from './utils/response';
import { DashboardTemplate } from './views/dashboard';
import { AuditService } from './services/audit';
import { getTokenMarketData } from './services/market';

// --- CORE MODULES ---
import authRouter from './routes/core/auth';
import healthRouter from './routes/core/health';
import webhooksRouter from './routes/core/webhooks';

// --- PLATFORM MODULES ---
import paymentsRouter from './routes/platform/payments';
import storageRouter from './routes/platform/storage';

// --- PRODUCT MODULES ---
import agroRouter from './routes/products/agro';
import rwaRouter from './routes/products/rwa';
import blogRouter from './routes/products/blog';

// Configura√ß√£o de Tipagem do Hono
type Variables = {
  db: Database;
};

type AppType = {
  Bindings: Bindings;
  Variables: Variables;
};

const app = new Hono<AppType>();

// =================================================================
// 1. MIDDLEWARES GLOBAIS
// =================================================================

// 1.1 CORS Din√¢mico para suporte a Vercel e Localhost
app.use('/*', async (c, next) => {
  const corsMiddleware = cors({
    origin: (origin) => {
      const allowedOrigins = [
        'http://localhost:8080',
        'http://localhost:3000',
        'https://asppibra.com', 
        'https://www.asppibra.com', 
        'https://api.asppibra.com',
        'https://social-fi-asppibra.vercel.app' // Adicione sua URL espec√≠fica da Vercel
      ];
      // Permite localhost, dom√≠nios de desenvolvimento da Cloudflare e origens oficiais
      if (origin && (
        origin.includes('localhost') || 
        origin.includes('cloudworkstations.dev') || 
        origin.includes('.vercel.app') || 
        allowedOrigins.includes(origin)
      )) {
        return origin;
      }
      return allowedOrigins[0]; // Fallback seguro para produ√ß√£o
    },
    allowHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-App-ID', 'x-admin-key'],
    allowMethods: ['POST', 'GET', 'OPTIONS', 'PUT', 'DELETE'],
    exposeHeaders: ['Content-Length'],
    maxAge: 600,
    credentials: true,
  });
  return corsMiddleware(c, next);
});

// 1.2 Database Injection (Scoped)
app.use(async (c, next) => {
  if (!c.env.DB) {
    return error(c, 'Binding DB n√£o configurado no wrangler.toml', null, 500);
  }
  const db = createDb(c.env.DB);
  c.set('db', db);
  await next();
});

// 1.3 Audit & Telemetry com WaitUntil (Performance)
app.use('*', async (c, next) => {
  const start = Date.now();
  await next(); 

  const path = c.req.path;
  // Ignora logs de telemetria para assets e rotas de sa√∫de
  if (!path.match(/\.(css|js|png|jpg|ico|json|map)$/) && !path.startsWith('/api/core/health')) {
    const audit = new AuditService(c.env);
    const executionTime = Date.now() - start;
    const cf = (c.req.raw as any).cf;

    c.executionCtx.waitUntil(
      audit.log({
        action: "API_REQUEST",
        ip: c.req.header("cf-connecting-ip") || "unknown",
        country: c.req.header("cf-ipcountry") || "XX",
        userAgent: c.req.header("user-agent"),
        status: c.res.ok ? "success" : "failure",
        metadata: {
          path: path,
          method: c.req.method,
          executionTimeMs: executionTime,
          city: cf?.city       
        }
      })
    );
  }
});

// =================================================================
// 2. ROTAS DE DASHBOARD E MONITORAMENTO
// =================================================================

app.get('/', async (c) => {
  const audit = new AuditService(c.env);
  const metrics = await audit.getDashboardMetrics();
  
  const domain = c.req.url.includes('localhost') ? "http://localhost:8787" : "https://api.asppibra.com";

  return c.html(DashboardTemplate({
    version: "1.1.0",
    service: "Central System API",
    cacheRatio: (metrics as any).cacheRatio || "N/A", 
    domain: domain,
    imageUrl: `${domain}/img/social-preview.png`
  }));
});

app.get('/api/stats', async (c) => {
  const audit = new AuditService(c.env);
  return c.json(await audit.getDashboardMetrics());
});

// =================================================================
// 3. API & ROTAS MODULARES
// =================================================================

app.route('/api/core/auth', authRouter);
app.route('/api/core/health', healthRouter);
app.route('/api/core/webhooks', webhooksRouter);
app.route('/api/platform/payments', paymentsRouter);
app.route('/api/platform/storage', storageRouter);
app.route('/api/products/agro', agroRouter);
app.route('/api/products/rwa', rwaRouter);
app.route('/api/posts', blogRouter); // SocialFi Integration

// =================================================================
// 4. ARQUIVOS EST√ÅTICOS & ERROS
// =================================================================

app.get('/static/*', async (c) => {
  return await c.env.ASSETS.fetch(c.req.raw as any) as unknown as Response;
});

app.notFound((c) => c.json({ success: false, message: 'Rota n√£o encontrada (404)' }, 404));

app.onError((err, c) => {
  console.error('üî• Server Error:', err);
  return c.json({ success: false, message: 'Internal Server Error', error: err.message }, 500);
});

export default {
  fetch: app.fetch,
  
  // Worker CRON: Atualiza√ß√£o de Mercado e Estat√≠sticas
  async scheduled(event: ScheduledEvent, env: Bindings, ctx: ExecutionContext) {
    ctx.waitUntil((async () => {
      await updateTokenPrice(env);
      const audit = new AuditService(env);
      await audit.computeGlobalStats();
    })());
  },
};

// L√≥gica de Atualiza√ß√£o de Cache KV (Pre√ßos de Token)
async function updateTokenPrice(env: Bindings) {
  try {
    const newData = await getTokenMarketData(env, 'price_only');
    if (newData && env.KV_CACHE) {
      await env.KV_CACHE.put("market:data", JSON.stringify(newData));
      await env.KV_CACHE.put("market:price_usd", newData.price.toString());
    }
  } catch (error) {
    console.error("‚ùå Cron: Erro na atualiza√ß√£o", error);
  }
}
--- Arquivo: src/routes/products/blog.ts ---
/**
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Blog & SocialFi API (Unified & Revised)
 * Version: 2.1.0
 */

import { Hono } from 'hono';
import { z } from 'zod';
import { zValidator } from '@hono/zod-validator';
import { desc, eq, sql } from 'drizzle-orm';
import { posts, users, postFavorites, auditLogs } from '../../db/schema'; // Import auditLogs
import { requireAuth } from '../../middleware/auth';
import { Database } from '../../db';

// Schema Zod para cria√ß√£o/edi√ß√£o, alinhado ao banco de dados
const createPostSchema = z.object({
  title: z.string().min(3, "O t√≠tulo √© muito curto"),
  content: z.string().min(10, "O conte√∫do √© muito curto"),
  slug: z.string().regex(/^[a-z0-9-]+$/, "Slug inv√°lido"),
  description: z.string().max(160, "A descri√ß√£o √© muito longa").optional(),
  category: z.string().optional().default('Geral'),
  coverUrl: z.string().url("URL da imagem de capa inv√°lida").optional(),
  tags: z.array(z.string()).optional().default([]),
  publish: z.boolean().optional().default(true),
  isFeatured: z.boolean().optional().default(false),
  isTrending: z.boolean().optional().default(false),
});

// Schema Zod para validar o par√¢metro :id
const postIdSchema = z.object({
  id: z.string().regex(/^\d+$/, "ID de post inv√°lido").transform(Number),
});


type AppType = {
  Bindings: { DB: D1Database; JWT_SECRET: string };
  Variables: { db: Database; user: { userId: number; role: string } };
};

const blog = new Hono<AppType>();

// =================================================================
// 1. ROTAS P√öBLICAS (LEITURA)
// =================================================================

blog.get('/', async (c) => {
  const db = c.get('db');
  
  try {
    const data = await db
      .select({
        id: posts.id,
        title: posts.title,
        slug: posts.slug,
        description: posts.description,
        category: posts.category,
        coverUrl: posts.coverUrl,
        totalViews: posts.totalViews,
        totalFavorites: posts.totalFavorites,
        isFeatured: posts.isFeatured,
        isTrending: posts.isTrending,
        publish: posts.publish,
        createdAt: posts.createdAt,
        author: {
          id: users.id,
          name: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,
          avatarUrl: users.avatarUrl,
        },
      })
      .from(posts)
      .leftJoin(users, eq(posts.authorId, users.id))
      .where(eq(posts.publish, true)) 
      .orderBy(desc(posts.createdAt))
      .limit(30);

    return c.json({ success: true, data });
  } catch (error) {
    console.error("Erro ao buscar feed:", error);
    return c.json({ success: false, message: 'Erro ao buscar feed.' }, 500);
  }
});

blog.get('/:slug', async (c) => {
  const db = c.get('db');
  const slug = c.req.param('slug');

  try {
    const [post] = await db
      .select({
        id: posts.id,
        title: posts.title,
        content: posts.content,
        description: posts.description,
        slug: posts.slug,
        category: posts.category,
        tags: posts.tags,
        coverUrl: posts.coverUrl,
        totalViews: posts.totalViews,
        totalFavorites: posts.totalFavorites,
        createdAt: posts.createdAt,
        author: {
          id: users.id,
          name: sql<string>`${users.firstName} || \' \' || ${users.lastName}`,
          avatarUrl: users.avatarUrl,
        },
      })
      .from(posts)
      .leftJoin(users, eq(posts.authorId, users.id))
      .where(eq(posts.slug, slug));
    
    if (!post) return c.json({ success: false, message: 'Post n√£o encontrado' }, 404);

    const favorites = await db
      .select({
        name: sql<string>`${users.firstName}`,
        avatarUrl: users.avatarUrl,
      })
      .from(postFavorites)
      .leftJoin(users, eq(postFavorites.userId, users.id))
      .where(eq(postFavorites.postId, post.id))
      .limit(5);

    c.executionCtx.waitUntil(
      db.update(posts)
        .set({ totalViews: sql`${posts.totalViews} + 1` })
        .where(eq(posts.id, post.id))
    );

    // Drizzle/D1 com modo 'json' j√° faz o parse, ent√£o 'tags' deve ser um array.
    return c.json({ success: true, data: { ...post, favoritePerson: favorites } });

  } catch (error) {
    console.error(`Erro ao carregar artigo [${slug}]:`, error);
    return c.json({ success: false, message: 'Erro ao carregar artigo.' }, 500);
  }
});

// =================================================================
// 2. ROTAS PRIVADAS (A√ß√µes SocialFi & Escrita)
// =================================================================

blog.use('/*', requireAuth());

// Criar Post
blog.post('/', zValidator('json', createPostSchema), async (c) => {
  const db = c.get('db');
  const user = c.get('user');
  const postData = c.req.valid('json');

  try {
    const [newPost] = await db.insert(posts).values({
      ...postData,
      authorId: user.userId,
    }).returning();

    // üü¢ AUDITORIA FORENSE
    c.executionCtx.waitUntil(
      db.insert(auditLogs).values({
        actorId: user.userId,
        action: 'BLOG_POST_CREATE',
        status: 'success',
        ipAddress: c.req.header('cf-connecting-ip') || 'unknown',
        metadata: { postId: newPost.id, slug: newPost.slug }
      })
    );

    return c.json({ success: true, data: newPost }, 201);
  } catch (error: any) {
    console.error("Erro ao criar post:", error);
    // Erro de slug duplicado
    if (error.message?.includes('UNIQUE constraint failed: posts.slug')) {
        return c.json({ success: false, message: 'Este slug j√° est√° em uso.'}, 409);
    }
    return c.json({ success: false, message: 'N√£o foi poss√≠vel criar o post.' }, 500);
  }
});

// Favoritar Post
blog.post('/:id/favorite', zValidator('param', postIdSchema), async (c) => {
  const db = c.get('db');
  const userId = c.get('user').userId;
  const { id: postId } = c.req.valid('param');

  try {
    await db.insert(postFavorites).values({ userId, postId });
    
    c.executionCtx.waitUntil(
        db.update(posts)
          .set({ totalFavorites: sql`${posts.totalFavorites} + 1` })
          .where(eq(posts.id, postId))
    );

    return c.json({ success: true, message: 'Favoritado com sucesso!' });
  } catch (error: any) {
    if (error.message?.includes('UNIQUE constraint failed')) {
      return c.json({ success: false, message: 'Voc√™ j√° favoritou este post.' }, 409);
    }
    console.error(`Erro ao favoritar post [${postId}]:`, error);
    return c.json({ success: false, message: 'N√£o foi poss√≠vel completar a a√ß√£o.' }, 500);
  }
});

export default blog;
--- Arquivo: src/routes/products/rwa/index.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';
import { ContentfulStatusCode } from 'hono/utils/http-status';

const rwa = new Hono<{ Bindings: Bindings }>();

// --- CONFIGURA√á√ïES ---
const TOKEN_ADDRESS = '0x0697AB2B003FD2Cbaea2dF1ef9b404E45bE59d4C';
// Endere√ßo do Par de Liquidez (Validado no Terminal)
const PAIR_ADDRESS = '0xf1961269D193f6511A1e24aaC93FBCA4E815e4Ca'; 
const CHAIN = 'bsc';

// ROTA 1: Dados Atuais (Snapshot)
// Cache curto de 15s para manter o pre√ßo "vivo"
rwa.get('/token-data', async (c) => {
  const apiKey = c.env.MORALIS_API_KEY;
  if (!apiKey) return c.json({ error: 'Config Error' }, 500);

  c.header('Cache-Control', 'public, max-age=15');

  const url = `https://deep-index.moralis.io/api/v2.2/erc20/${TOKEN_ADDRESS}/price?chain=${CHAIN}`;

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json', 'X-API-Key': apiKey }
    });

    if (!response.ok) {
       return c.json({ success: false, error: 'Moralis Error' }, 500);
    }
    const data = await response.json();
    return c.json({ success: true, data: data });

  } catch (e) { return c.json({ error: 'Internal Error' }, 500); }
});

// ROTA 2: Hist√≥rico Real de 1 Ano (OHLCV do Par)
// ‚úÖ CACHE: 6 Horas (21600 segundos) - Economia Extrema para Plano Free
rwa.get('/token-history', async (c) => {
  const apiKey = c.env.MORALIS_API_KEY;
  if (!apiKey) return c.json({ error: 'Config Error' }, 500);

  c.header('Cache-Control', 'public, max-age=21600');

  // 1. Calcula datas din√¢micas (Hoje e 1 Ano atr√°s)
  const today = new Date();
  const oneYearAgo = new Date();
  oneYearAgo.setFullYear(today.getFullYear() - 1);

  const toDate = today.toISOString().split('T')[0];
  const fromDate = oneYearAgo.toISOString().split('T')[0];

  // 2. Par√¢metros validados no teste via Terminal
  const params = new URLSearchParams({
    chain: CHAIN,
    timeframe: '1d',     // Velas Di√°rias
    currency: 'usd',
    limit: '365',        // 1 Ano
    fromDate: fromDate,  // Obrigat√≥rio para endpoint de pares
    toDate: toDate       // Obrigat√≥rio para endpoint de pares
  });

  // Usa endpoint de PARES (/pairs/address/ohlcv) em vez de token
  const url = `https://deep-index.moralis.io/api/v2.2/pairs/${PAIR_ADDRESS}/ohlcv?${params.toString()}`;

  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: { 'Accept': 'application/json', 'X-API-Key': apiKey }
    });

    if (!response.ok) {
       const err = await response.text();
       console.error("Moralis History Error:", err);
       // Retorna array vazio em vez de erro 500 para n√£o quebrar o site visualmente
       return c.json({ success: true, data: [] }); 
    }

    const json = await response.json();
    // @ts-ignore
    const history = json.result || [];
    
    // 3. Ordena√ß√£o: Garante que os dados estejam do Antigo -> Novo
    // (Importante para o gr√°fico SVG desenhar na dire√ß√£o certa)
    const sortedHistory = history.sort((a: any, b: any) => 
        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
    );

    return c.json({ success: true, data: sortedHistory });

  } catch (e) { 
      console.error("History Fetch Error:", e);
      return c.json({ error: 'History Error' }, 500); 
  }
});

export default rwa;
--- Arquivo: src/routes/products/agro/index.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';

const app = new Hono<{ Bindings: Bindings }>();

app.get('/', (c) => c.json({ module: 'AgroDAO', status: 'active' }));

export default app;
--- Arquivo: src/routes/products/posts/index.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { success } from '../../../utils/response';
import { Database } from '../../../db';

// Mock post data
const mockPosts = [
  {
    id: '1',
    title: 'Post de Exemplo 1',
    content: 'Este √© o conte√∫do do primeiro post.',
    createdAt: new Date().toISOString(),
    category: 'Testing',
    coverUrl: '/assets/images/mock/cover/cover-1.webp',
    totalViews: 500,
    totalComments: 20,
    totalShares: 10,
    description: 'Um post inicial para testes',
    tags: ['teste', 'exemplo'],
    isPublished: true,
    comments: [],
    meta: { title: 'Post 1', description: 'Meta Desc 1'},
    author: { name: 'Admin', avatarUrl: '/assets/images/mock/avatar/avatar-1.webp'}
  },
  {
    id: '2',
    title: 'Outro Post Interessante',
    content: 'Aqui falamos sobre desenvolvimento com Hono e Cloudflare.',
    createdAt: new Date().toISOString(),
    category: 'Development',
    coverUrl: '/assets/images/mock/cover/cover-2.webp',
    totalViews: 1200,
    totalComments: 45,
    totalShares: 30,
    description: 'Um post sobre desenvolvimento web moderno',
    tags: ['hono', 'cloudflare', 'dev'],
    isPublished: true,
    comments: [],
    meta: { title: 'Post 2', description: 'Meta Desc 2'},
    author: { name: 'Developer', avatarUrl: '/assets/images/mock/avatar/avatar-2.webp'}
  },
];

const app = new Hono<{ Variables: { db: Database } }>();

// Rota: GET /api/post/list
app.get('/list', (c) => {
  return success(c, { posts: mockPosts }, 'Posts recuperados com sucesso!');
});

// Rota: GET /api/post/:title
app.get('/:title', (c) => {
  const title = c.req.param('title');
  const post = mockPosts.find(p => p.title === title);

  if (!post) {
    return c.json({ error: 'Post n√£o encontrado' }, 404);
  }

  return success(c, { post }, 'Post recuperado com sucesso!');
});

export default app;

--- Arquivo: src/routes/core/webhooks.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';

const app = new Hono<{ Bindings: Bindings }>();

app.post('/', (c) => c.json({ module: 'Webhooks', received: true }));

export default app;
--- Arquivo: src/routes/core/health.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';

const app = new Hono<{ Bindings: Bindings }>();

// 1. Health Check Simples (Ping)
app.get('/', (c) => {
  return c.json({
    status: 'ok',
    system: 'CENTRAL-SYSTEM-API',
    timestamp: new Date().toISOString()
  });
});

// 2. Health Check do Banco de Dados
app.get('/db', async (c) => {
  // Como o middleware global j√° injetou o DB, se chegou aqui, o DB instanciou.
  // Podemos fazer uma query simples para garantir.
  try {
    const db = c.get('db' as any); // Recupera do contexto
    // Opcional: const result = await db.run(sql`SELECT 1`);
    return c.json({ status: 'ok', message: 'DB Connected' });
  } catch (e: any) {
    return c.json({ status: 'error', message: e.message }, 500);
  }
});

// 3. Monitoramento Avan√ßado (Cloudflare GraphQL)
// Movido do index.ts antigo para c√°
app.get('/analytics', async (c) => {
  const accountId = c.env.CLOUDFLARE_ACCOUNT_ID;
  const zoneId = c.env.CLOUDFLARE_ZONE_ID;
  const apiToken = c.env.CLOUDFLARE_API_TOKEN;

  if (!accountId || !zoneId || !apiToken) {
    return c.json({ error: 'Configura√ß√£o incompleta de Observabilidade' }, 500);
  }

  const now = new Date();
  const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
  const isoStart = oneDayAgo.toISOString();
  const isoEnd = now.toISOString();
  const dateStart = isoStart.split('T')[0];

  const query = `
    query {
      viewer {
        accounts(filter: { accountTag: "${accountId}" }) {
          d1: d1AnalyticsAdaptiveGroups(limit: 1, filter: { date_geq: "${dateStart}" }) {
            sum { readQueries, writeQueries }
          }
        }
        zones(filter: { zoneTag: "${zoneId}" }) {
          traffic: httpRequestsAdaptiveGroups(limit: 1, filter: { datetime_geq: "${isoStart}", datetime_lt: "${isoEnd}" }) {
            count
            sum { edgeResponseBytes }
          }
          cache: httpRequestsAdaptiveGroups(limit: 5, filter: { datetime_geq: "${isoStart}", datetime_lt: "${isoEnd}" }, orderBy: [count_DESC]) {
            count
            dimensions { cacheStatus }
          }
          countries: httpRequestsAdaptiveGroups(limit: 5, filter: { datetime_geq: "${isoStart}", datetime_lt: "${isoEnd}" }, orderBy: [count_DESC]) {
            count
            dimensions { clientCountryName }
          }
        }
      }
    }
  `;

  try {
    const cfResponse = await fetch('https://api.cloudflare.com/client/v4/graphql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiToken}` },
      body: JSON.stringify({ query })
    });

    const cfData: any = await cfResponse.json();

    if (cfData.errors) {
      console.error("Erro Cloudflare:", JSON.stringify(cfData.errors));
      return c.json({ error: 'Erro API Cloudflare', details: cfData.errors }, 500);
    }

    const zoneData = cfData?.data?.viewer?.zones?.[0] || {};
    const accountData = cfData?.data?.viewer?.accounts?.[0] || {};
    const trafficRaw = zoneData.traffic?.[0] || { count: 0, sum: { edgeResponseBytes: 0 } };
    const dbMetrics = accountData.d1?.[0]?.sum || { readQueries: 0, writeQueries: 0 };
    const cacheRaw = zoneData.cache || [];
    const totalCacheReqs = cacheRaw.reduce((acc: number, item: any) => acc + item.count, 0);
    const hits = cacheRaw.find((i: any) => ['hit', 'revalidated'].includes(i.dimensions.cacheStatus))?.count || 0;
    const cacheRatio = totalCacheReqs > 0 ? ((hits / totalCacheReqs) * 100).toFixed(0) : "0";

    const countries = (zoneData.countries || []).map((item: any) => ({
      code: item.dimensions.clientCountryName,
      count: item.count
    }));

    return c.json({
      requests: trafficRaw.count,
      bytes: trafficRaw.sum.edgeResponseBytes,
      cacheRatio: cacheRatio,
      dbReads: dbMetrics.readQueries,
      dbWrites: dbMetrics.writeQueries,
      countries: countries
    });

  } catch (e: any) {
    console.error("Monitoring Exception:", e.message);
    return c.json({ error: 'Falha interna', msg: e.message }, 500);
  }
});

export default app;
--- Arquivo: src/routes/core/auth/index.ts ---
import { Hono } from 'hono';
import { eq } from 'drizzle-orm';
import { sign } from 'hono/jwt';
import { users, auditLogs } from '../../../db/schema'; // ‚úÖ CORRE√á√ÉO: Usando auditLogs
import { success, error } from '../../../utils/response';
import { hashPassword, comparePassword } from '../../../services/auth';
import { Bindings } from '../../../types/bindings';

const auth = new Hono<{ Bindings: Bindings }>();

// ==========================================
// 1. REGISTRO (SIGN UP)
// ==========================================
auth.post('/register', async (c) => {
  const db = c.get('db' as any);
  const { email, password, firstName, lastName } = await c.req.json();

  try {
    // Verifica se o usu√°rio j√° existe
    const existingUser = await db.select().from(users).where(eq(users.email, email)).get();
    if (existingUser) {
      return error(c, 'Este e-mail j√° est√° cadastrado', null, 400);
    }

    // Hash da senha e inser√ß√£o
    const hashedPassword = await hashPassword(password);
    
    const newUser = await db.insert(users).values({
      email,
      password: hashedPassword,
      firstName, // ‚úÖ Gravando o Nome
      lastName,  // ‚úÖ Gravando o Sobrenome
      role: 'citizen',
    }).returning().get();

    // Log de Auditoria
    c.executionCtx.waitUntil(
      db.insert(auditLogs).values({
        action: 'USER_REGISTER',
        actorId: newUser.id.toString(),
        status: 'success',
        metadata: { email: newUser.email }
      })
    );

    // Gera token para j√° deixar logado ap√≥s registro
    const token = await sign({ id: newUser.id, role: newUser.role }, c.env.JWT_SECRET);

    return success(c, 'Conta criada com sucesso', { accessToken: token, user: newUser });
  } catch (e: any) {
    return error(c, 'Erro ao criar conta', e.message, 500);
  }
});

// ==========================================
// 2. LOGIN (SIGN IN)
// ==========================================
auth.post('/login', async (c) => {
  const db = c.get('db' as any);
  const { email, password } = await c.req.json();

  try {
    const user = await db.select().from(users).where(eq(users.email, email)).get();

    if (!user || !(await comparePassword(password, user.password))) {
      return error(c, 'E-mail ou senha incorretos', null, 401);
    }

    const token = await sign(
      { 
        id: user.id, 
        role: user.role,
        exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24) // 24h
      }, 
      c.env.JWT_SECRET
    );

    return success(c, 'Bem-vindo de volta', { accessToken: token, user });
  } catch (e: any) {
    return error(c, 'Erro no processo de login', e.message, 500);
  }
});

// ==========================================
// 3. PERFIL (ME) - Usado pelo AuthProvider
// ==========================================
auth.get('/me', async (c) => {
  const db = c.get('db' as any);
  const payload = c.get('jwtPayload' as any); // Preenchido pelo middleware de auth

  if (!payload) return error(c, 'N√£o autorizado', null, 401);

  const user = await db.select().from(users).where(eq(users.id, payload.id)).get();
  
  if (!user) return error(c, 'Usu√°rio n√£o encontrado', null, 404);

  return success(c, 'Usu√°rio carregado', { user });
});

export default auth;
--- Arquivo: src/routes/core/auth/password.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
--- Arquivo: src/routes/core/auth/session.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { hash } from 'bcryptjs';
import { zValidator } from '@hono/zod-validator';
import { signUpSchema } from '../../../validators/auth'; // ‚úÖ Corrigido: Nome do export
import { users, audit_logs } from '../../../db/schema';
import { success, error } from '../../../utils/response';
import { Database } from '../../../db';
import { eq } from 'drizzle-orm';

// Tipagem do contexto para garantir acesso ao banco D1
const app = new Hono<{ Variables: { db: Database } }>();

// ----------------------------------------------------------------------
// Rota: POST /register
// ----------------------------------------------------------------------
app.post(
  '/register', 
  zValidator('json', signUpSchema), // ‚úÖ Corrigido: Usando signUpSchema
  
  async (c) => {
    const db = c.get('db');
    const data = c.req.valid('json');

    try {
      // 1. Verificar se email j√° existe
      const existingUser = await db.select().from(users).where(eq(users.email, data.email)).limit(1);

      if (existingUser.length > 0) {
        return error(c, 'Este e-mail j√° est√° cadastrado.', null, 409);
      }

      // 2. Criptografar a senha
      const passwordHash = await hash(data.password, 10);

      // 3. Salvar no Banco (Sincronizado com schema.ts)
      const [newUser] = await db.insert(users).values({
        firstName: data.firstName, // ‚úÖ Corrigido: Campo split
        lastName: data.lastName,   // ‚úÖ Corrigido: Campo split
        email: data.email,
        password: passwordHash,
        role: 'citizen',           // ‚úÖ Corrigido: Enum institucional
        emailVerified: false,
      }).returning({
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
        role: users.role,
        createdAt: users.createdAt
      });

      // 4. Registro de Auditoria Forense
      await db.insert(audit_logs).values({
        actorId: String(newUser.id),
        action: 'register',
        resource: `users:${newUser.id}`,
        status: 'success',
        ipAddress: c.req.header('cf-connecting-ip') || 'unknown',
        userAgent: c.req.header('user-agent'),
      });

      return success(c, newUser, 'Usu√°rio criado com sucesso!', 201);

    } catch (err: any) {
      console.error('Erro no registro:', err);
      return error(c, 'Falha ao processar registro institucional', err.message, 500);
    }
  }
);

export default app;
--- Arquivo: src/routes/platform/storage.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';

const app = new Hono<{ Bindings: Bindings }>();

app.get('/', (c) => c.json({ module: 'IPFS', status: 'active' }));

export default app;
--- Arquivo: src/routes/platform/payments.ts ---
/**
 * Copyright 2025 ASPPIBRA ‚Äì Associa√ß√£o dos Propriet√°rios e Possuidores de Im√≥veis no Brasil.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Project: Governance System (ASPPIBRA DAO)
 * Role: Central System API & Identity Provider
 */
import { Hono } from 'hono';
import { Bindings } from '../../types/bindings';

const app = new Hono<{ Bindings: Bindings }>();

app.get('/', (c) => c.json({ module: 'Payments', status: 'active' }));

export default app;
------------------------------------------------

‚òÅÔ∏è 4. CONFIGURA√á√ÉO CLOUDFLARE (wrangler.toml):
wrangler.toml n√£o encontrado.
